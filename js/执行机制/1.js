// ============================================================================
// 经典面试题：变量提升 + 函数声明提升 + 参数优先级
// ============================================================================


// var a = 1;
// function fn(a) {
//     console.log(a);
//     var a = 2;
//     console.log(a);
//     function a() {};
//     var b = a;
//     console.log(a);
// }
// fn(3);



// 全局作用域
var a = 1;  // 全局变量a，存储在全局执行上下文的变量环境中

// ============================================================================
// 函数定义：fn
// ============================================================================
function fn(a) {  // 参数a，这是关键！参数会被添加到函数执行上下文中
    
    // 📝 这里开始分析 fn 函数的执行上下文
    // 当调用 fn(3) 时，会创建一个新的函数执行上下文
    
    // ============================================================================
    // 【阶段1：创建阶段 - Creation Phase】
    // ============================================================================
    // 创建阶段会按照以下顺序处理：
    // 
    // 步骤1️⃣: 处理参数（Arguments）
    //    a = 3  （传入的实参）
    //
    // 步骤2️⃣: 处理函数声明（Function Declarations）
    //    function a() {} 
    //    ⚠️ 注意：函数声明会覆盖同名的参数！
    //    此时 a = function a() {}
    //
    // 步骤3️⃣: 处理变量声明（Variable Declarations）
    //    var a = ?
    //    var b = ?
    //    ⚠️ 关键：如果变量名已存在（a已经是函数了），则跳过声明，不会覆盖！
    //    所以 a 仍然是 function a() {}
    //    b 被声明并初始化为 undefined
    //
    // 创建阶段结束时，函数执行上下文：
    // FunctionContext = {
    //   VariableEnvironment: {
    //     a: function a() {},  // ✅ 函数声明覆盖了参数
    //     b: undefined         // ✅ var声明，初始化为undefined
    //   }
    // }
    
    // ============================================================================
    // 【阶段2：执行阶段 - Execution Phase】
    // ============================================================================
    
    // 🔍 第1行执行：console.log(a)
    console.log(a);  
    // 此时 a = function a() {}
    // 输出：[Function: a]
    // 
    // 📊 当前状态：
    // a = function a() {}
    // b = undefined
    
    // 🔍 第2行执行：var a = 2
    var a = 2;  
    // var a 在创建阶段已经处理过了，这里只执行赋值操作
    // a = 2  （将数字2赋值给a，覆盖了函数）
    //
    // 📊 当前状态：
    // a = 2
    // b = undefined
    
    // 🔍 第3行执行：function a() {}
    function a() {};  
    // 函数声明在创建阶段已经完全处理过了
    // 执行阶段会跳过函数声明，什么都不做！
    //
    // 📊 当前状态：
    // a = 2  （没有变化）
    // b = undefined
    
    // 🔍 第4行执行：var b = a
    var b = a;  
    // var b 在创建阶段已声明，这里只执行赋值
    // b = a = 2
    //
    // 📊 当前状态：
    // a = 2
    // b = 2
    
    // 🔍 第5行执行：console.log(a)
    console.log(a);  
    // 此时 a = 2
    // 输出：2
    //
    // 📊 最终状态：
    // a = 2
    // b = 2
}

// ============================================================================
// 【全局执行】
// ============================================================================

// 🚀 调用函数
fn(3);  
// 输出：
// [Function: a]  （第一个console.log）
// 2              （第二个console.log）

// 🌍 访问全局变量
console.log(a);  
// 输出：1
// 原因：全局变量a一直是1，函数内的a是局部变量，不影响全局


// ============================================================================
// 【完整执行流程图解】
// ============================================================================
//
// 1. 全局执行上下文创建：
//    GlobalContext = {
//      a: undefined → 1,
//      fn: <function>
//    }
//
// 2. 调用 fn(3)，创建函数执行上下文：
//    
//    创建阶段：
//    ┌─────────────────────────────────┐
//    │ 1. 参数：a = 3                  │
//    │ 2. 函数声明：a = function a(){} │  ← 覆盖参数
//    │ 3. var声明：a已存在，跳过        │
//    │             b = undefined        │
//    └─────────────────────────────────┘
//    
//    执行阶段：
//    ┌─────────────────────────────────┐
//    │ console.log(a) → function a(){} │
//    │ a = 2                           │
//    │ (function a(){} 已提升，跳过)   │
//    │ b = 2                           │
//    │ console.log(a) → 2              │
//    └─────────────────────────────────┘
//
// 3. 函数执行完毕，返回全局上下文：
//    console.log(a) → 1  （全局的a）
//
// ============================================================================


// ============================================================================
// 【关键知识点总结】
// ============================================================================
//
// ✅ 1. 变量提升（Hoisting）
//    - var声明会提升到作用域顶部
//    - 提升时初始化为undefined
//    - 赋值操作不会提升
//
// ✅ 2. 函数声明提升
//    - 函数声明会完整提升（包括函数体）
//    - 优先级：函数声明 > 参数 > var声明
//    - 同名时，函数声明会覆盖参数
//
// ✅ 3. 参数处理
//    - 参数在创建阶段首先被处理
//    - 参数相当于局部变量
//    - 会被后续的函数声明覆盖
//
// ✅ 4. 执行上下文的两个阶段
//    创建阶段：
//      - 确定this绑定
//      - 创建词法环境和变量环境
//      - 处理参数、函数声明、变量声明
//    
//    执行阶段：
//      - 逐行执行代码
//      - 变量赋值
//      - 函数调用
//
// ✅ 5. 优先级规则（同名标识符）
//    函数声明 > 参数 > var声明
//    但是！赋值操作总是会覆盖现有值
//
// ============================================================================


// ============================================================================
// 【常见误区】
// ============================================================================
//
// ❌ 误区1：认为参数a不会被覆盖
//    错误！函数声明 function a(){} 会覆盖参数a
//
// ❌ 误区2：认为 var a = 2 会重新声明变量
//    错误！var a 在创建阶段已经处理过，执行阶段只做赋值
//
// ❌ 误区3：认为执行阶段还会处理 function a(){}
//    错误！函数声明在创建阶段已完全提升，执行阶段会忽略
//
// ❌ 误区4：认为函数内的a会影响全局的a
//    错误！函数内的a是局部变量，与全局a完全独立
//
// ============================================================================


// ============================================================================
// 【面试答题模板】
// ============================================================================
//
// 问：这段代码的输出是什么？为什么？
//
// 答：输出是：
//    [Function: a]
//    2
//    1
//
// 原因：
// 1. fn(3)调用时，创建函数执行上下文
// 2. 创建阶段，处理顺序为：参数(a=3) → 函数声明(a=function) → var声明(跳过a，声明b)
// 3. 执行阶段，第一个console.log输出function a(){}
// 4. var a = 2 执行赋值，a变为2
// 5. 第二个console.log输出2
// 6. 全局console.log输出全局变量a，值为1
//
// ============================================================================