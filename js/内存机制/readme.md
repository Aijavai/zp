# JS内存机制

- JS 执行机制
  - 调用栈
  - 执行上下文
    - 词法环境
    - 变量环境
    - outer 词法作用域链
      - 闭包 closure
    - this


- JS 内存
  - 栈内存 简单数据类型
  - 堆内存 复杂数据类型


- JS是什么语言？  动态弱类型语言
  - 静态语言  C Java
    使用之前需要确认变量数据类型的
  - 动态语言  JavaScript 
    运行过程中需要检查变量数据类型
    - 强类型

    - 弱类型
      各种类型都可以转换
- js 要直接操作内存不？
  不需要
  c, c++ malloc free 操作内存
  js 不用操作内存

- Object 类型
  key: value  
- 为什么是这两个？
  

## 代码空间
- 代码空间
  代码从硬盘
  读取到内存中
- 栈内存
  调用栈 （JS 执行的主角）
  快，好管理，大小固定
  调用栈的栈顶切换要快，小，连续 切换还很频繁
- 堆内存
  打辅助
  大对象的空间，分配更耗时
  对象动态的，不连续

  JavaScript V8引擎需要用栈来维护程序执行期间上下文的状态。
  如果栈空间太大了，不连续的（复杂数据类型也放在栈中），那么会影响上下文切换的效率，
  进而影响这个程序的执行效率
  执行上下文的切换，其实是执行栈栈顶指针的偏移。
  栈空间，用来存放原始数据类型，空间暂居不大，且连续
  堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。
  
  - 简单数据类型直接使用，
  - 复杂数据类型，二传手
    回收的时候 栈回收（指针偏移） 堆内存中的对象没有变量引用，慢慢回收。

## 内存机制理解闭包
- 执行流程
  - 先编译 foo 函数，创建一个空执行上下文（全局执行上下文）
  - 执行foo 之前，编译过程，setName, getName 快速的词法扫描（var）
  闭包内部函数，myName test1 由内部函数引用的自由变量，JS判断有闭包，堆空间中创建一个closure(foo)

  - getName, setName 执行可以访问到closure(foo) 

  闭包核心 第一步 需要扫描内部函数 堆内存中 
  第二步 把内部函数引用的外部变量保存到堆中。

简单数据类型是执行顺序在栈内存中顺手创建的