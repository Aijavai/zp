# JS 语言工作的底层机制
  - v8 引擎
  - 调用栈
    - 编译阶段 
    - 执行阶段
  - 执行上下文（底部全局执行上下文，其他都是函数执行上下文）
  - 作用域
    变量的查找范围和生命周期
    - 块级作用域 栈结构的词法环境
    - hosisting提升（变量提升） 简单高效

## 作用域链
- 不知道作用域链查找的规则？
  - 一定要知道作用域链的查找规则
  - 作用域链 变量的查找路径
    按函数声明的时候（编译），已经决定 词法作用域
- 为什么是全局的作用域
  - 为什么不是foo()? 极客帮
    函数在**调用栈**中的顺序  不是这样的

## 词法作用域 以及词法作用域链
指作用域是由代码中函数声明的位置来决定的。词法作用域是静态的作用域
作用域链也叫词法作用域链，静态的，只和函数声明的位置相关，在编译阶段
就决定好了，和调用没有关系。
outer 指针指向代码编写位置时的执行上下文


## 闭包 closure 
无处不在的高级概念
静态的，词法作用域后
- 函数运行的时候，也有一种情况
  就好像函数运行的时候不是在它声明的位置时，作用域链

- 闭包基于词法作用域链的理解
- 形成条件是函数嵌套函数
- 被闭包的函数要在外部可以访问到 return 
- 被闭包的函数执行的时候能找到定义它的时候的执行上下文中的变量，

foo 函数执行完后，其执行上下文从栈顶弹出了，但是由于返回的setName,getName 使用了foo 函数内部的变量 myName,test1 这两个变量依然在内存
中，有点像给getName, setName 方法背的一个专属背包。
这个背包叫作闭包，这个闭包里面的变量叫自由变量

  作用域是变量查找的规则，作用域链是变量查找的路径
  执行上下文在编译的时候创建（在代码编译的那一刹那）
  调用栈是以函数为单位
  函数执行的顺序和词法作用域链的顺序不一致，词法作用域是静态，函数执行是动态的